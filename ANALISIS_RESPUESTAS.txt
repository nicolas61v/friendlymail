ANALISIS DEL SISTEMA DE RESPUESTA DE EMAILS
============================================

1. FLUJO GENERAL
===============
EMAIL -> SINCRONIZACION -> BUSCAR AIRole -> PROCESAR IA -> CREAR RESPUESTA

Dos puntos de entrada:
A) Manual: sync_emails_api (views.py lineas 235-328)
B) Automatico: auto_sync_emails command (cada 5 min)

2. VERIFICACION DE AIRole
=========================

Ubicacion: ai_service.py lineas 236-275 (process_email method)

try:
    # Obtener rol activo
    ai_role = AIRole.objects.get(user=user, is_active=True)
except AIRole.DoesNotExist:
    # NO existe rol -> ESCALADA automatica
    intent = EmailIntent.objects.create(
        email=email,
        intent_type='unclear',
        confidence_score=0.0,
        ai_decision='escalate',  # <-- DECISION: ESCALADA
        decision_reason='No active AI role configured',
        processing_time_ms=0
    )
    return intent, None  # NO crea AIResponse

VALIDACIONES:
- Rol debe existir
- is_active=True (solo 1 activo por usuario)
- can_respond_topics NO puede estar vacio (REQUERIDO)
- Si falla -> EmailIntent con decision='escalate'

3. ANALISIS DE EMAIL (OpenAI)
=============================

Ubicacion: ai_service.py lineas 27-89 (analyze_email_intent)

System Prompt contiene:
- ai_role.name (nombre del rol)
- ai_role.system_prompt (contexto)
- can_respond_topics (temas permitidos)
- CRITICAL RULES:
  1. Si tema NOT en allowed list -> decision='escalate'
  2. Si tema en cannot_respond_topics -> escalate
  3. Solo respond si confidence > 0.7

OpenAI retorna JSON:
{
  "intent_type": "exam_info",
  "confidence": 0.95,
  "decision": "respond",
  "reason": "..."
}

4. BUSCAR TEMPORAL RULE
=======================

Ubicacion: ai_service.py lineas 317-340 (_find_matching_rule)

active_rules = TemporalRule.objects.filter(
    ai_role=ai_role,              # De este rol
    status='active',              # Activo
    start_date__lte=now,         # Vigente
    end_date__gte=now
).order_by('-priority')           # Ordenado por priority DESC

for rule in active_rules:
    email_content = f"{email.subject} {email.body_plain}".lower()
    keywords = [kw.strip().lower() for kw in rule.keywords.split(',')]
    
    if any(keyword in email_content for keyword in keywords):
        return rule  # PRIMERA COINCIDENCIA

return None  # Si nada coincide

RESULTADO:
- Se guarda en EmailIntent.matched_rule
- Se pasa a generate_response(matched_rule)
- IA usa rule.response_template como base

5. CREAR EMAIL INTENT
====================

EmailIntent.objects.create(
    email=email,
    intent_type=analysis['intent_type'],      # Tipo detectado
    confidence_score=analysis['confidence'],  # 0.0-1.0
    ai_decision=analysis['decision'],         # respond/escalate/ignore
    decision_reason=analysis['reason'],       # Explicacion
    matched_rule=matched_rule,                # Regla coincidente
    processing_time_ms=analysis['processing_time_ms']
)

SIEMPRE se crea este registro, documenta el analisis.

6. GENERAR RESPUESTA (si decision=='respond')
==============================================

Ubicacion: ai_service.py lineas 294-315

if analysis['decision'] == 'respond':
    response_text = self.analyzer.generate_response(email, ai_role, matched_rule)
    
    AIResponse.objects.create(
        email_intent=intent,
        response_text=response_text,
        response_subject=f"Re: {email.subject}",
        status='pending_approval'  # <-- ESTADO INICIAL
    )

System prompt incluye:
- ai_role.name y context
- Si matched_rule: rule.name, description, response_template
- Instrucciones para escribir respuesta

7. AUTO-ENVIO (si auto_send=True)
=================================

Ubicacion: management/commands/auto_sync_emails.py lineas 106-131

if ai_context.auto_send and ai_response.status == 'pending_approval':
    try:
        gmail_service.send_email(
            to_email=sender,
            subject=response_subject,
            body=response_text,
            reply_to_message_id=email.provider_id
        )
        
        ai_response.status = 'sent'
        ai_response.sent_at = timezone.now()
        ai_response.save()
        
    except Exception as e:
        # Si falla -> estado 'approved' para reintento manual
        ai_response.status = 'approved'
        ai_response.save()

CONDICIONES:
- AIRole.auto_send == True
- AIResponse.status == 'pending_approval'
- send_email() exitoso

8. ARCHIVOS CLAVE
=================

MODELOS:
- AIRole (ai_models.py lineas 60-169)
  * can_respond_topics: REQUERIDO
  * is_active: solo 1 por usuario
  * save() method: garantiza exclusividad
  * get_active_role(): obtiene rol activo

- TemporalRule (ai_models.py lineas 171-225)
  * ai_role: regla para un rol
  * start_date/end_date: vigencia
  * keywords: activacion
  * response_template: plantilla
  * status: draft/active/disabled

- EmailIntent (ai_models.py lineas 227-268)
  * email: OneToOneField
  * ai_decision: respond/escalate/ignore
  * decision_reason: explicacion
  * matched_rule: regla coincidente
  * confidence_score: 0.0-1.0

- AIResponse (ai_models.py lineas 270-301)
  * email_intent: OneToOneField
  * response_text/subject
  * status: pending_approval/approved/sent/failed
  * generated_at/approved_at/sent_at

SERVICIOS:
- EmailAIProcessor.process_email() (ai_service.py lineas 236-315)
  Orquesta: get role -> analyze -> find rule -> create intent -> generate

- AIEmailAnalyzer.analyze_email_intent() (lineas 27-89)
  Llama OpenAI para obtener decision

- AIEmailAnalyzer.generate_response() (lineas 90-128)
  Llama OpenAI para generar texto

- EmailAIProcessor._find_matching_rule() (lineas 317-340)
  Busca regla temporal coincidente

VISTAS:
- sync_emails_api() (views.py lineas 235-328)
- ai_role_create() (lineas 998-1047)
- ai_role_edit() (lineas 1051-1100)
- ai_role_activate() (lineas 1104-1124)
- approve_response() (lineas 532-607)
- ai_responses() (lineas 438-528)

9. DIAGNOSTICO
==============

¿AI no responde?
- Verificar: AIRole.objects.filter(user=user, is_active=True)
- Verificar: role.can_respond_topics no vacio
- Ver logs de process_email()

¿Respuestas no se envian automaticamente?
- Verificar: AIRole.auto_send=True
- Verificar: AIResponse.status='pending_approval' antes de send
- Ver logs de send_email()

¿Reglas temporales no funcionan?
- Verificar: status='active'
- Verificar: start_date <= now <= end_date
- Verificar: keywords en email (case-insensitive)
- Verificar: order by priority DESC
